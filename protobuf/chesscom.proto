syntax = "proto3";

import "google/protobuf/timestamp.proto";

option csharp_namespace = "ChessCom";

package chesscom;

// Defines the service
service ChessCom {
    // Function invoked to send the request
	rpc Login(LoginForm) returns (LoginResult) {}
	rpc LookForMatch(UserIdentity) returns (LookForMatchResult) {}
	rpc Match(stream MovePacket) returns (stream MoveResult) {}
	rpc ChatMessageStream(stream ChatMessage) returns (stream ChatMessage) {}
	rpc HostGame(HostedGame) returns (LookForMatchResult) {}
	rpc AvailableGames(Void) returns (HostedGamesMap) {} //TODO need another metod when list becomes to long
	rpc JoinGame(JoinGameRequest) returns (LookForMatchResult) {}

	rpc Alive(Heartbeat) returns (Heartbeat) {} //This exist to make sure both client and server still exists and is working.
												//If server has not recived an Alive Heartbeat from a logged in user in
												//2 minutes the user will be force logged out. Clients are recomendet to send
												//Alive Heartbeat every 1 minute
	rpc MatchEventListener(MatchId) returns (stream MovePacket) {}
	rpc SendMove(MovePacket) returns (Void) {}
	rpc ChatMessageListenter(UserData) returns (stream ChatMessage) {}
	rpc SendChatMessage(ChatMessage) returns (Void) {}
}

message Void{}

enum MatchEvent {
	Non = 0;
	WhiteWin = 1;
	BlackWin = 2;
	Draw = 3;
	UnexpectedClosing = 4;
	WhiteAskingForDraw = 5;
	BlackAskingForDraw = 6;
	ExpectedClosing = 7;
	//AcceptingDraw = 6;
}

enum Pices {
	None = 0;
	BlackPawn = 1;
	BlackKnight = 2;
	BlackBishop = 3;
	BlackRook = 4;
	BlackQueen = 5;
	BlackKing = 6;
	WhitePawn = 7;
	WhiteKnight = 8;
	WhiteBishop = 9;
	WhiteRook = 10;
	WhiteQueen = 11;
	WhiteKing = 12;
}

enum ChessType
{
	Classic = 0;
	FisherRandom = 1;
	SlugRandom = 2;
}

enum SideType
{
	HostIsWhite = 0;
	HostIsBlack = 1;
	Random = 2;
}

message Heartbeat
{
	bool alive = 1;
	string usertoken = 2;
}

message MatchId
{
	string matchId = 1;
}

message VisionRules {
	bool enabled = 1;
	bool viewMoveFields = 2;
	int32 viewRange = 3;
	map<int32, VisionRules> piceOverwriter = 4; //Must be a Pices value
	bool viewCaptureField = 5;
}

message TimeRules {
	Time playerTime = 2;
	int32 secondsPerMove = 3;
}

message GameRules
{
	VisionRules visionRules = 1;
	TimeRules timeRules = 2;
	ChessType chessType = 3;
	SideType sideType = 4;
}

message HostedGame 
{
	GameRules gameRules = 1;
    //string hostUsertoken = 2;
    //string joinerUsertoken = 3;
	int32 id = 4;
	//string hostUsername = 5;
	//string joinerUsername = 6;
	//int32 hostElo = 7;
	UserData host = 8;
	UserData joiner = 9;
}

message HostedGamesMap
{
	map<int32, HostedGame> hostedGames = 1;
}

message HostedGameResult
{
	bool foundUpponent = 1;

}

message Time {
	int32 minutes = 1;
	int32 seconds = 2;
}

message FieldMoves{
	repeated string list = 1;
}

message Move {
	string from = 2;
	string to = 3;
	google.protobuf.Timestamp timestamp = 4;
	int32 secSpent = 5;
	repeated bool whiteVision = 6;
	repeated bool blackVision = 7;
	repeated Pices pices = 8;
	map<string, FieldMoves> availableMoves = 9;
	map<string, FieldMoves> availableShadowMoves = 11;
	Pices capturedPice = 10;
	map<string, FieldMoves> whiteShadowMoves = 12;
	map<string, FieldMoves> blackShadowMoves = 13;
	map<string, FieldMoves> whiteMoves = 14;
	map<string, FieldMoves> blackMoves = 15;
	repeated string check = 16;
}

message GameState{
	string from = 2;
	string to = 3;
	google.protobuf.Timestamp timestamp = 4;
	int32 sec_spent = 5;
	repeated bool player_vision = 7;
	repeated Pices pices = 8;
	map<string, FieldMoves> player_moves = 9;
	map<string, FieldMoves> shadow_moves = 11;
	Pices captured_pice = 10;
	repeated string check = 16;
}

message LoginForm {
	string username = 1;
	string encryptedPassword = 5;
	string majorVersion = 2;
	string minorVersion = 3;
	string buildVersion = 4;
}

message LoginResult {
	bool successfullLogin = 1;
	//bool versionCorrect = 3;
	//string userToken = 2;
	string loginMessage = 4;
	UserData userData = 5;
}

message UserIdentity {
	string userToken = 1;
}

message UserData {
	string username = 1;
	string usertoken = 2;
	int32 elo = 3;
}

message LookForMatchResult {
	bool succes = 1;
	string matchToken = 2;
	bool isWhitePlayer = 3;
	//VisionRules rules = 4;    //TODO deprocate
	//string opponentUsername = 5;
	//TimeRules timerules = 6;  //TODO deprocate
	GameRules gameRules = 7;  // this hold both
	UserData opponentUserData = 8;
}

message MovePacket{
	bool doingMove = 1;
	Move move = 2;
	string userToken = 3;
	bool askingForDraw = 4;
	MatchEvent cheatMatchEvent = 5;
	string matchToken = 6;
}
message MoveResult{
	bool moveHappned = 1;
	//Move move = 2;
	GameState game_state = 2;
	bool opponentAskingForDraw = 4;
	MatchEvent matchEvent = 5;
	int32 secsLeft = 6;
}

message JoinGameRequest 
{
	int32 id = 1;
	UserData joiner = 2;
}

message ChatMessage {
	//for validation
	string senderUsertoken = 1; 
	
	string senderUsername = 2; //sender username
	string reciverUsertoken = 3; //reciver userToken
	string message = 4;
}
